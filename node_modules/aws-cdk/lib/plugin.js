"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const safe_1 = require("colors/safe");
const logging_1 = require("./logging");
/**
 * A utility to manage plug-ins.
 *
 * @experimental
 */
class PluginHost {
    constructor() {
        /**
         * Access the currently registered CredentialProviderSources. New sources can
         * be registered using the +registerCredentialProviderSource+ method.
         */
        this.credentialProviderSources = new Array();
        if (PluginHost.instance && PluginHost.instance !== this) {
            throw new Error('New instances of PluginHost must not be built. Use PluginHost.instance instead!');
        }
    }
    /**
     * Loads a plug-in into this PluginHost.
     *
     * @param moduleSpec the specification (path or name) of the plug-in module to be loaded.
     */
    load(moduleSpec) {
        try {
            // tslint:disable-next-line:no-var-requires
            const plugin = require(moduleSpec);
            if (!isPlugin(plugin)) {
                logging_1.error(`Module ${safe_1.green(moduleSpec)} is not a valid plug-in, or has an unsupported version.`);
                throw new Error(`Module ${moduleSpec} does not define a valid plug-in.`);
            }
            if (plugin.init) {
                plugin.init(PluginHost.instance);
            }
        }
        catch (e) {
            logging_1.error(`Unable to load ${safe_1.green(moduleSpec)}: ${e.stack}`);
            throw new Error(`Unable to load plug-in: ${moduleSpec}`);
        }
        function isPlugin(x) {
            return x != null && x.version === '1';
        }
    }
    /**
     * Allows plug-ins to register new CredentialProviderSources.
     *
     * @param source a new CredentialProviderSource to register.
     */
    registerCredentialProviderSource(source) {
        this.credentialProviderSources.push(source);
    }
}
exports.PluginHost = PluginHost;
PluginHost.instance = new PluginHost();
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicGx1Z2luLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsicGx1Z2luLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7O0FBQUEsc0NBQW9DO0FBR3BDLHVDQUFrQztBQWtDbEM7Ozs7R0FJRztBQUNILE1BQWEsVUFBVTtJQVNyQjtRQU5BOzs7V0FHRztRQUNhLDhCQUF5QixHQUFHLElBQUksS0FBSyxFQUE0QixDQUFDO1FBR2hGLElBQUksVUFBVSxDQUFDLFFBQVEsSUFBSSxVQUFVLENBQUMsUUFBUSxLQUFLLElBQUksRUFBRTtZQUN2RCxNQUFNLElBQUksS0FBSyxDQUFDLGlGQUFpRixDQUFDLENBQUM7U0FDcEc7SUFDSCxDQUFDO0lBRUQ7Ozs7T0FJRztJQUNJLElBQUksQ0FBQyxVQUFrQjtRQUM1QixJQUFJO1lBQ0YsMkNBQTJDO1lBQzNDLE1BQU0sTUFBTSxHQUFHLE9BQU8sQ0FBQyxVQUFVLENBQUMsQ0FBQztZQUNuQyxJQUFJLENBQUMsUUFBUSxDQUFDLE1BQU0sQ0FBQyxFQUFFO2dCQUNyQixlQUFLLENBQUMsVUFBVSxZQUFLLENBQUMsVUFBVSxDQUFDLHlEQUF5RCxDQUFDLENBQUM7Z0JBQzVGLE1BQU0sSUFBSSxLQUFLLENBQUMsVUFBVSxVQUFVLG1DQUFtQyxDQUFDLENBQUM7YUFDMUU7WUFDRCxJQUFJLE1BQU0sQ0FBQyxJQUFJLEVBQUU7Z0JBQUUsTUFBTSxDQUFDLElBQUksQ0FBQyxVQUFVLENBQUMsUUFBUSxDQUFDLENBQUM7YUFBRTtTQUN2RDtRQUFDLE9BQU8sQ0FBQyxFQUFFO1lBQ1YsZUFBSyxDQUFDLGtCQUFrQixZQUFLLENBQUMsVUFBVSxDQUFDLEtBQUssQ0FBQyxDQUFDLEtBQUssRUFBRSxDQUFDLENBQUM7WUFDekQsTUFBTSxJQUFJLEtBQUssQ0FBQywyQkFBMkIsVUFBVSxFQUFFLENBQUMsQ0FBQztTQUMxRDtRQUVELFNBQVMsUUFBUSxDQUFDLENBQU07WUFDdEIsT0FBTyxDQUFDLElBQUksSUFBSSxJQUFJLENBQUMsQ0FBQyxPQUFPLEtBQUssR0FBRyxDQUFDO1FBQ3hDLENBQUM7SUFDSCxDQUFDO0lBRUQ7Ozs7T0FJRztJQUNJLGdDQUFnQyxDQUFDLE1BQWdDO1FBQ3RFLElBQUksQ0FBQyx5QkFBeUIsQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLENBQUM7SUFDOUMsQ0FBQzs7QUE5Q0gsZ0NBK0NDO0FBOUNlLG1CQUFRLEdBQUcsSUFBSSxVQUFVLEVBQUUsQ0FBQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGdyZWVuIH0gZnJvbSAnY29sb3JzL3NhZmUnO1xuXG5pbXBvcnQgeyBDcmVkZW50aWFsUHJvdmlkZXJTb3VyY2UgfSBmcm9tICcuL2FwaS9hd3MtYXV0aC9jcmVkZW50aWFscyc7XG5pbXBvcnQgeyBlcnJvciB9IGZyb20gJy4vbG9nZ2luZyc7XG5cbi8qKlxuICogVGhlIGJhc2ljIGNvbnRyYWN0IGZvciBwbHVnLWlucyB0byBhZGhlcmUgdG86OlxuICpcbiAqICAgaW1wb3J0IHsgUGx1Z2luLCBQbHVnaW5Ib3N0IH0gZnJvbSAnYXdzLWNkayc7XG4gKiAgIGltcG9ydCB7IEN1c3RvbUNyZWRlbnRpYWxQcm92aWRlclNvdXJjZSB9IGZyb20gJy4vY3VzdG9tLWNyZWRlbnRpYWwtcHJvdmlkZXItc291cmNlJztcbiAqXG4gKiAgIGV4cG9ydCBkZWZhdWx0IGNsYXNzIEZvb0NES1BsdWdJbiBpbXBsZW1lbnRzIFBsdWdpbkhvc3Qge1xuICogICAgIHB1YmxpYyByZWFkb25seSB2ZXJzaW9uID0gJzEnO1xuICpcbiAqICAgICBwdWJsaWMgaW5pdChob3N0OiBQbHVnaW5Ib3N0KSB7XG4gKiAgICAgaG9zdC5yZWdpc3RlckNyZWRlbnRpYWxQcm92aWRlclNvdXJjZShuZXcgQ3VzdG9tQ3JlZGVudGlhbFByb3ZpZGVyU291cmNlKCkpO1xuICogICAgIH1cbiAqICAgfVxuICpcbiAqIEBleHBlcmltZW50YWxcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBQbHVnaW4ge1xuICAvKipcbiAgICogVGhlIHZlcnNpb24gb2YgdGhlIHBsdWctaW4gaW50ZXJmYWNlIHVzZWQgYnkgdGhlIHBsdWctaW4uIFRoaXMgd2lsbCBiZSB1c2VkIGJ5XG4gICAqIHRoZSBwbHVnLWluIGhvc3QgdG8gaGFuZGxlIHZlcnNpb24gY2hhbmdlcy5cbiAgICovXG4gIHZlcnNpb246ICcxJztcblxuICAvKipcbiAgICogV2hlbiBkZWZpbmVkLCB0aGlzIGZ1bmN0aW9uIGlzIGludm9rZWQgcmlnaHQgYWZ0ZXIgdGhlIHBsdWctaW4gaGFzIGJlZW4gbG9hZGVkLFxuICAgKiBzbyB0aGF0IHRoZSBwbHVnLWluIGlzIGFibGUgdG8gaW5pdGlhbGl6ZSBpdHNlbGYuIEl0IG1heSBjYWxsIG1ldGhvZHMgb2YgdGhlXG4gICAqIGBgUGx1Z2luSG9zdGBgIGluc3RhbmNlIGl0IHJlY2VpdmVzIHRvIHJlZ2lzdGVyIG5ldyBgYENyZWRlbnRpYWxQcm92aWRlclNvdXJjZWBgXG4gICAqIGluc3RhbmNlcy5cbiAgICovXG4gIGluaXQ/OiAoaG9zdDogUGx1Z2luSG9zdCkgPT4gdm9pZDtcbn1cblxuLyoqXG4gKiBBIHV0aWxpdHkgdG8gbWFuYWdlIHBsdWctaW5zLlxuICpcbiAqIEBleHBlcmltZW50YWxcbiAqL1xuZXhwb3J0IGNsYXNzIFBsdWdpbkhvc3Qge1xuICBwdWJsaWMgc3RhdGljIGluc3RhbmNlID0gbmV3IFBsdWdpbkhvc3QoKTtcblxuICAvKipcbiAgICogQWNjZXNzIHRoZSBjdXJyZW50bHkgcmVnaXN0ZXJlZCBDcmVkZW50aWFsUHJvdmlkZXJTb3VyY2VzLiBOZXcgc291cmNlcyBjYW5cbiAgICogYmUgcmVnaXN0ZXJlZCB1c2luZyB0aGUgK3JlZ2lzdGVyQ3JlZGVudGlhbFByb3ZpZGVyU291cmNlKyBtZXRob2QuXG4gICAqL1xuICBwdWJsaWMgcmVhZG9ubHkgY3JlZGVudGlhbFByb3ZpZGVyU291cmNlcyA9IG5ldyBBcnJheTxDcmVkZW50aWFsUHJvdmlkZXJTb3VyY2U+KCk7XG5cbiAgY29uc3RydWN0b3IoKSB7XG4gICAgaWYgKFBsdWdpbkhvc3QuaW5zdGFuY2UgJiYgUGx1Z2luSG9zdC5pbnN0YW5jZSAhPT0gdGhpcykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdOZXcgaW5zdGFuY2VzIG9mIFBsdWdpbkhvc3QgbXVzdCBub3QgYmUgYnVpbHQuIFVzZSBQbHVnaW5Ib3N0Lmluc3RhbmNlIGluc3RlYWQhJyk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIExvYWRzIGEgcGx1Zy1pbiBpbnRvIHRoaXMgUGx1Z2luSG9zdC5cbiAgICpcbiAgICogQHBhcmFtIG1vZHVsZVNwZWMgdGhlIHNwZWNpZmljYXRpb24gKHBhdGggb3IgbmFtZSkgb2YgdGhlIHBsdWctaW4gbW9kdWxlIHRvIGJlIGxvYWRlZC5cbiAgICovXG4gIHB1YmxpYyBsb2FkKG1vZHVsZVNwZWM6IHN0cmluZykge1xuICAgIHRyeSB7XG4gICAgICAvLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmU6bm8tdmFyLXJlcXVpcmVzXG4gICAgICBjb25zdCBwbHVnaW4gPSByZXF1aXJlKG1vZHVsZVNwZWMpO1xuICAgICAgaWYgKCFpc1BsdWdpbihwbHVnaW4pKSB7XG4gICAgICAgIGVycm9yKGBNb2R1bGUgJHtncmVlbihtb2R1bGVTcGVjKX0gaXMgbm90IGEgdmFsaWQgcGx1Zy1pbiwgb3IgaGFzIGFuIHVuc3VwcG9ydGVkIHZlcnNpb24uYCk7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgTW9kdWxlICR7bW9kdWxlU3BlY30gZG9lcyBub3QgZGVmaW5lIGEgdmFsaWQgcGx1Zy1pbi5gKTtcbiAgICAgIH1cbiAgICAgIGlmIChwbHVnaW4uaW5pdCkgeyBwbHVnaW4uaW5pdChQbHVnaW5Ib3N0Lmluc3RhbmNlKTsgfVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGVycm9yKGBVbmFibGUgdG8gbG9hZCAke2dyZWVuKG1vZHVsZVNwZWMpfTogJHtlLnN0YWNrfWApO1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbmFibGUgdG8gbG9hZCBwbHVnLWluOiAke21vZHVsZVNwZWN9YCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXNQbHVnaW4oeDogYW55KTogeCBpcyBQbHVnaW4ge1xuICAgICAgcmV0dXJuIHggIT0gbnVsbCAmJiB4LnZlcnNpb24gPT09ICcxJztcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQWxsb3dzIHBsdWctaW5zIHRvIHJlZ2lzdGVyIG5ldyBDcmVkZW50aWFsUHJvdmlkZXJTb3VyY2VzLlxuICAgKlxuICAgKiBAcGFyYW0gc291cmNlIGEgbmV3IENyZWRlbnRpYWxQcm92aWRlclNvdXJjZSB0byByZWdpc3Rlci5cbiAgICovXG4gIHB1YmxpYyByZWdpc3RlckNyZWRlbnRpYWxQcm92aWRlclNvdXJjZShzb3VyY2U6IENyZWRlbnRpYWxQcm92aWRlclNvdXJjZSkge1xuICAgIHRoaXMuY3JlZGVudGlhbFByb3ZpZGVyU291cmNlcy5wdXNoKHNvdXJjZSk7XG4gIH1cbn1cbiJdfQ==